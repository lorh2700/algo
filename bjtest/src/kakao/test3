{"model":{"question":"\u003cstyle type=\"text/css\"\u003e.ps-content-wrapper-v0 div { margin: 0 auto; overflow: auto; } .ps-content-wrapper-v0 div.preheader { display: none; } .ps-content-wrapper-v0 p { white-space: pre-wrap; padding-left: 4px; padding-right: 4px; padding-top: 0px; padding-bottom: 2px; } .ps-content-wrapper-v0 p.section-title { font-weight: bold; padding-bottom: 0px; } .ps-content-wrapper-v0 ol.plain-list, .ps-content-wrapper-v0 ul.plain-list { list-style-type: none; padding: 4px; } .ps-content-wrapper-v0 li { white-space: normal; margin-top: 4px; margin-bottom: 4px; } .ps-content-wrapper-v0 code { color: black; } .ps-content-wrapper-v0 pre { background-color: #f4faff; border: 0; border-radius: 2px; margin: 8px; padding: 10px; } .ps-content-wrapper-v0 figure { background-color: transparent; display: table; margin-top: 8px; margin-bottom: 8px; text-align: center; margin-left: auto; margin-right: auto; } .ps-content-wrapper-v0 figcaption { text-align: center; display: table-caption; caption-side: bottom; margin-top: 4px; margin-bottom: 4px; } .ps-content-wrapper-v0 img { width: auto; max-width: 100%; height: auto; } .ps-content-wrapper-v0 details { background-color: transparent; padding-left: 4px; padding-right: 4px; padding-top: 0px; padding-bottom: 2px; } .ps-content-wrapper-v0 details summary { background-color: #39424e; color: white; font-weight: bold; margin-top: 4px; margin-bottom: 4px; padding: 8px; } .ps-content-wrapper-v0 details div.collapsable-details { margin: 0 auto; padding-left: 4px; padding-right: 4px; padding-top: 0px; padding-bottom: 2px; overflow: auto; } .ps-content-wrapper-v0 details div.collapsable-details pre { margin-left: 4px; margin-right: 4px; margin-top: 4px; margin-bottom: 4px; } .ps-content-wrapper-v0 table { border: 1px solid black; border-collapse: collapse; border-color: darkgray; margin: 0 auto; margin-top: 8px; margin-bottom: 8px; padding: 8px; width: 96%; table-layout: fixed; } .ps-content-wrapper-v0 table tbody tr th, .ps-content-wrapper-v0 table tbody tr td { font-weight: bold; white-space: nowrap; text-align: center; vertical-align: middle; border: 1px solid black; border-color: darkgray; padding: 8px; } .ps-content-wrapper-v0 table tbody tr th.description { width: 60%; } .ps-content-wrapper-v0 table tbody tr td { font-weight: normal; white-space: normal; } .ps-content-wrapper-v0 table.function-params tbody tr:first-child td.headers { border-bottom-width: 2px; } .ps-content-wrapper-v0 table.function-params tbody tr:last-child td { border-top-width: 2px; border-top-color: darkgray; } .ps-content-wrapper-v0 table.function-params tbody tr td.headers { width: 25%; font-weight: bold; text-align: center; border: 1px solid black; border-right-width: 2px; border-color: darkgray; } .ps-content-wrapper-v0 table.function-params tbody tr td.params-table-cell { width: 100%; height: 100%; padding: 0px; } .ps-content-wrapper-v0 table.function-params tbody tr td.params-table-cell table.params-table { width: 100%; height: 100%; padding: 0px; margin: 0px; border: 0; } .ps-content-wrapper-v0 table.function-params tbody tr td.params-table-cell table.params-table tbody tr td.code { white-space: normal; } .ps-content-wrapper-v0 table.function-params tbody tr td.params-table-cell table.params-table tbody tr th { border-top: 0; } .ps-content-wrapper-v0 table.function-params tbody tr td.params-table-cell table.params-table tbody tr th:first-child { border-left: 0; } .ps-content-wrapper-v0 table.function-params tbody tr td.params-table-cell table.params-table tbody tr th:last-child { border-right: 0; } .ps-content-wrapper-v0 table.function-params tbody tr td.params-table-cell table.params-table tbody tr:last-child td { border-bottom: 0; border-top-width: 1px; } .ps-content-wrapper-v0 table.function-params tbody tr td.params-table-cell table.params-table tbody tr td:first-child { border-left: 0; } .ps-content-wrapper-v0 table.function-params tbody tr td.params-table-cell table.params-table tbody tr td:last-child { border-right: 0; } .ps-content-wrapper-v0 .left { text-align: left; } .ps-content-wrapper-v0 .right { text-align: right; } .ps-content-wrapper-v0 .code { font-family: monospace; white-space: nowrap; } .ps-content-wrapper-v0 .json-object-array ol, .ps-content-wrapper-v0 .json-object-array ol ul { margin-top: 0px; padding-left: 14px; } .json-object-array li { float: left; margin-right: 30px; margin-left: 10px; } .json-object-array pre { padding: 4px; margin-left: 0px; }\n\u003c/style\u003e\n\u003cdiv class=\"ps-content-wrapper-v0\"\u003e\n\u003cdiv style=\"display:none;font-size:1px;color:#333333;line-height:1px;overflow:hidden;\"\u003eFind the maximum of the minimum values in each subarray of size x.\u003c/div\u003e\n\n\u003cp\u003eYou are at the grocery store trying to determine which cereal to buy. There is a row of different cereal brands in front of you, represented as an \u003cem\u003en\u003c/em\u003e-element array.\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003eYou would like to find a cereal that is not too pricey but also not the most inexpensive. To do this, you scan every subarray of size \u003cem\u003ex\u003c/em\u003e, starting from index 0. Subarrays are to be contiguous blocks of elements in the inclusive range from index \u003cem\u003ei\u003c/em\u003e to index \u003cem\u003ej\u003c/em\u003e, where \u003cem\u003ej − i + 1 = x\u003c/em\u003e and \u003cem\u003e0 ≤ i ≤ j \u0026lt; n. \u003c/em\u003eThen, among each of these subarrays, find the cereal with the minimum price. Return the value of the maximum among these.\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003eFor example, given array \u003cem\u003earr=[8, 2, 4]\u003c/em\u003e, the subarrays of size \u003cem\u003ex = 2\u003c/em\u003e would be \u003cem\u003e[8, 2]\u003c/em\u003e and \u003cem\u003e[2, 4]\u003c/em\u003e. The minimum values of the two subarrays are \u003cem\u003e[2, 2]\u003c/em\u003e. The maximum of those two minimum values is \u003cem\u003e2\u003c/em\u003e. This is the value you need to determine, which represents the price of the cereal you decide to purchase.\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eFunction Description \u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003eComplete the function \u003cem\u003esegment\u003c/em\u003e in the editor below. Your function must find the minimum value for each subarray of size \u003cem\u003ex\u003c/em\u003e in array \u003cem\u003earr,\u003c/em\u003e then return an integer denoting the \u003cem\u003emaximum\u003c/em\u003e of these minima.\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003esegment has the following parameter(s):\u003c/p\u003e\n\n\u003cp\u003e    \u003cem\u003ex:\u003c/em\u003e  an integer, the segment length\u003c/p\u003e\n\n\u003cp\u003e    \u003cem\u003earr[arr[0],...arr[n-1]]:\u003c/em\u003e  an array of integers\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eConstraints\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\n\u003cem\u003e1 \u003c/em\u003e≤\u003cem\u003e n \u003c/em\u003e≤\u003cem\u003e 10\u003csup\u003e6\u003c/sup\u003e\u003c/em\u003e\n\u003c/li\u003e\n\t\u003cli\u003e\n\u003cem\u003e1 \u003c/em\u003e≤\u003cem\u003e arr[i] \u003c/em\u003e≤\u003cem\u003e 10\u003csup\u003e9\u003c/sup\u003e\u003c/em\u003e\n\u003c/li\u003e\n\t\u003cli\u003e\n\u003cem\u003e1 \u003c/em\u003e≤\u003cem\u003e x \u003c/em\u003e≤\u003cem\u003e n\u003c/em\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\u003c!--       \u003cStartOfInputFormat\u003e DO NOT REMOVE THIS LINE--\u003e\n\n\u003cdetails\u003e\u003csummary class=\"section-title\"\u003eInput Format for Custom Testing\u003c/summary\u003e\n\n\u003cdiv class=\"collapsable-details\"\u003e\n\u003cp\u003eInput from stdin will be processed as follows and passed to the function:\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003eThe first line contains an integer, \u003cem\u003ex\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe second line contains an integer, \u003cem\u003en\u003c/em\u003e, which is the size of the array \u003cem\u003earr\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eEach of the next \u003cem\u003en\u003c/em\u003e lines contains the integer \u003cem\u003earr[i]\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\u003c/div\u003e\n\u003c/details\u003e\n\n\u003cdetails open=\"open\"\u003e\u003csummary class=\"section-title\"\u003eSample Case 0\u003c/summary\u003e\n\n\u003cdiv class=\"collapsable-details\"\u003e\n\u003cp\u003e\u003cstrong\u003eSample Input 0\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\nSTDIN        Function Parameters \n-----        -------------------                       \n1     →      x = 1\n5     →      arr[] Size n = 5\n1     →      arr[] = [ 1, 2, 3, 1, 2 ]\n2\n3\n1\n2\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eSample Output 1\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n3\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eExplanation 1\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003eThe following arguments are passed to your function:\u003c/p\u003e\n\n\u003cp\u003e\u003cem\u003ex = 1\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cem\u003earr[5] = [1, 2, 3, 1, 2]\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003eThe subarrays of size \u003cem\u003ex = 1\u003c/em\u003e are \u003cem\u003e[1]\u003c/em\u003e, \u003cem\u003e[2]\u003c/em\u003e, \u003cem\u003e[3]\u003c/em\u003e, \u003cem\u003e[1]\u003c/em\u003e, and \u003cem\u003e[2]\u003c/em\u003e. Because each subarray only contains \u003cem\u003e1\u003c/em\u003e element, each value is minimal with respect to the subarray it's in. We return the maximum of these values, which is \u003cem\u003e3\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\u003c/div\u003e\n\u003c/details\u003e\n\n\u003cdetails\u003e\u003csummary class=\"section-title\"\u003eSample Case 1\u003c/summary\u003e\n\n\u003cdiv class=\"collapsable-details\"\u003e\n\u003cp\u003e\u003cstrong\u003eSample Input 1\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\nSTDIN        Function Parameters\n-----        -------------------    \n2        →   x = 2\n3        →   arr[] Size n = 3\n1        →   arr[] = [ 1, 1, 1 ]\n1\n1\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eSample Output 1\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n1\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eExplanation 1\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003eThe following arguments are passed to your function:\u003c/p\u003e\n\n\u003cp\u003e\u003cem\u003ex = 2\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cem\u003earr[3] = [1, 1, 1]\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003eThe subarrays of size \u003cem\u003ex = 2\u003c/em\u003e are \u003cem\u003e[1, 1]\u003c/em\u003e and \u003cem\u003e[1, 1]\u003c/em\u003e. The minimum value for both subarrays is \u003cem\u003e1\u003c/em\u003e. We return the maximum of two \u003cem\u003e1s\u003c/em\u003e, which is \u003cem\u003e1\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\u003c/div\u003e\n\u003c/details\u003e\n\n\u003cdetails\u003e\u003csummary class=\"section-title\"\u003eSample Case 2\u003c/summary\u003e\n\n\u003cdiv class=\"collapsable-details\"\u003e\n\u003cp\u003e\u003cstrong\u003eSample Input 2\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\nSTDIN        Function Parameters\n-----        -------------------\n3        →   x = 3\n5        →   arr[] Size n = 5\n2        →   arr[] = [ 2, 5, 4, 6, 8 ]\n5\n4\n6\n8\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eSample Output 2\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n4\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eExplanation 2\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003eThe following arguments are passed to your function:\u003c/p\u003e\n\n\u003cp\u003e\u003cem\u003ex = 3\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cem\u003earr[5] = [2, 5, 4, 6, 8]\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003eThe subarrays of size \u003cem\u003ex = 3\u003c/em\u003e are \u003cem\u003e[2, 5, 4]\u003c/em\u003e, \u003cem\u003e[5, 4, 6]\u003c/em\u003e, and \u003cem\u003e[4, 6, 8]\u003c/em\u003e. The respective minimum values for the three subarrays are \u003cem\u003e2\u003c/em\u003e, \u003cem\u003e4\u003c/em\u003e, and \u003cem\u003e4\u003c/em\u003e. We return the maximum of these values, which is \u003cem\u003e4\u003c/em\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003c/details\u003e\n\u003c/div\u003e\n","type":"code","unique_id":"2stk0norq7b","languages":["c","clojure","cpp","cpp14","csharp","erlang","go","haskell","java","java8","javascript","julia","kotlin","lua","objectivec","perl","php","pypy","pypy3","python","python3","r","ruby","scala","swift"],"name":"Cereal Segments","hide_compile_test":null,"custom_testcase_allowed":"True","version":95,"sub_type":null,"stubs_present":"False","c_template":"/*\n * Complete the 'segment' function below.\n *\n * The function is expected to return an INTEGER.\n * The function accepts following parameters:\n *  1. INTEGER x\n *  2. INTEGER_ARRAY arr\n */\n\nint segment(int x, int arr_count, int* arr) {\n\n}\n\n","c_template_head":"#include \u003cassert.h\u003e\n#include \u003cctype.h\u003e\n#include \u003climits.h\u003e\n#include \u003cmath.h\u003e\n#include \u003cstdbool.h\u003e\n#include \u003cstddef.h\u003e\n#include \u003cstdint.h\u003e\n#include \u003cstdio.h\u003e\n#include \u003cstdlib.h\u003e\n#include \u003cstring.h\u003e\n\nchar* readline();\nchar* ltrim(char*);\nchar* rtrim(char*);\n\nint parse_int(char*);\n\n","c_template_tail":"int main()\n{\n    FILE* fptr = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n\n    int x = parse_int(ltrim(rtrim(readline())));\n\n    int arr_count = parse_int(ltrim(rtrim(readline())));\n\n    int* arr = malloc(arr_count * sizeof(int));\n\n    for (int i = 0; i \u003c arr_count; i++) {\n        int arr_item = parse_int(ltrim(rtrim(readline())));\n\n        *(arr + i) = arr_item;\n    }\n\n    int result = segment(x, arr_count, arr);\n\n    fprintf(fptr, \"%d\\n\", result);\n\n    fclose(fptr);\n\n    return 0;\n}\n\nchar* readline() {\n    size_t alloc_length = 1024;\n    size_t data_length = 0;\n\n    char* data = malloc(alloc_length);\n\n    while (true) {\n        char* cursor = data + data_length;\n        char* line = fgets(cursor, alloc_length - data_length, stdin);\n\n        if (!line) {\n            break;\n        }\n\n        data_length += strlen(cursor);\n\n        if (data_length \u003c alloc_length - 1 || data[data_length - 1] == '\\n') {\n            break;\n        }\n\n        alloc_length \u003c\u003c= 1;\n\n        data = realloc(data, alloc_length);\n\n        if (!data) {\n            data = '\\0';\n\n            break;\n        }\n    }\n\n    if (data[data_length - 1] == '\\n') {\n        data[data_length - 1] = '\\0';\n\n        data = realloc(data, data_length);\n\n        if (!data) {\n            data = '\\0';\n        }\n    } else {\n        data = realloc(data, data_length + 1);\n\n        if (!data) {\n            data = '\\0';\n        } else {\n            data[data_length] = '\\0';\n        }\n    }\n\n    return data;\n}\n\nchar* ltrim(char* str) {\n    if (!str) {\n        return '\\0';\n    }\n\n    if (!*str) {\n        return str;\n    }\n\n    while (*str != '\\0' \u0026\u0026 isspace(*str)) {\n        str++;\n    }\n\n    return str;\n}\n\nchar* rtrim(char* str) {\n    if (!str) {\n        return '\\0';\n    }\n\n    if (!*str) {\n        return str;\n    }\n\n    char* end = str + strlen(str) - 1;\n\n    while (end \u003e= str \u0026\u0026 isspace(*end)) {\n        end--;\n    }\n\n    *(end + 1) = '\\0';\n\n    return str;\n}\n\nint parse_int(char* str) {\n    char* endptr;\n    int value = strtol(str, \u0026endptr, 10);\n\n    if (endptr == str || *endptr != '\\0') {\n        exit(EXIT_FAILURE);\n    }\n\n    return value;\n}\n","clojure_template":";\n; Complete the 'segment' function below.\n;\n; The function is expected to return an INTEGER.\n; The function accepts following parameters:\n;  1. INTEGER x\n;  2. INTEGER_ARRAY arr\n;\n\n(defn segment [x arr]\n\n)\n\n","clojure_template_head":"\n\n","clojure_template_tail":"(def fptr (get (System/getenv) \"OUTPUT_PATH\"))\n\n(def x (Integer/parseInt (clojure.string/trim (read-line))))\n\n(def arr-count (Integer/parseInt (clojure.string/trim (read-line))))\n\n(def arr [])\n\n(doseq [_ (range arr-count)]\n    (def arr (conj arr (Integer/parseInt (clojure.string/trim (read-line)))))\n)\n\n(def result (segment x arr))\n\n(spit fptr (str result \"\\n\") :append true)\n","cpp_template":"/*\n * Complete the 'segment' function below.\n *\n * The function is expected to return an INTEGER.\n * The function accepts following parameters:\n *  1. INTEGER x\n *  2. INTEGER_ARRAY arr\n */\n\nint segment(int x, vector\u003cint\u003e arr) {\n\n}\n\n","cpp_template_head":"#include \u003cbits/stdc++.h\u003e\n\nusing namespace std;\n\nstring ltrim(const string \u0026);\nstring rtrim(const string \u0026);\n\n","cpp_template_tail":"int main()\n{\n    ofstream fout(getenv(\"OUTPUT_PATH\"));\n\n    string x_temp;\n    getline(cin, x_temp);\n\n    int x = stoi(ltrim(rtrim(x_temp)));\n\n    string arr_count_temp;\n    getline(cin, arr_count_temp);\n\n    int arr_count = stoi(ltrim(rtrim(arr_count_temp)));\n\n    vector\u003cint\u003e arr(arr_count);\n\n    for (int i = 0; i \u003c arr_count; i++) {\n        string arr_item_temp;\n        getline(cin, arr_item_temp);\n\n        int arr_item = stoi(ltrim(rtrim(arr_item_temp)));\n\n        arr[i] = arr_item;\n    }\n\n    int result = segment(x, arr);\n\n    fout \u003c\u003c result \u003c\u003c \"\\n\";\n\n    fout.close();\n\n    return 0;\n}\n\nstring ltrim(const string \u0026str) {\n    string s(str);\n\n    s.erase(\n        s.begin(),\n        find_if(s.begin(), s.end(), not1(ptr_fun\u003cint, int\u003e(isspace)))\n    );\n\n    return s;\n}\n\nstring rtrim(const string \u0026str) {\n    string s(str);\n\n    s.erase(\n        find_if(s.rbegin(), s.rend(), not1(ptr_fun\u003cint, int\u003e(isspace))).base(),\n        s.end()\n    );\n\n    return s;\n}\n","cpp14_template":"/*\n * Complete the 'segment' function below.\n *\n * The function is expected to return an INTEGER.\n * The function accepts following parameters:\n *  1. INTEGER x\n *  2. INTEGER_ARRAY arr\n */\n\nint segment(int x, vector\u003cint\u003e arr) {\n\n}\n\n","cpp14_template_head":"#include \u003cbits/stdc++.h\u003e\n\nusing namespace std;\n\nstring ltrim(const string \u0026);\nstring rtrim(const string \u0026);\n\n","cpp14_template_tail":"int main()\n{\n    ofstream fout(getenv(\"OUTPUT_PATH\"));\n\n    string x_temp;\n    getline(cin, x_temp);\n\n    int x = stoi(ltrim(rtrim(x_temp)));\n\n    string arr_count_temp;\n    getline(cin, arr_count_temp);\n\n    int arr_count = stoi(ltrim(rtrim(arr_count_temp)));\n\n    vector\u003cint\u003e arr(arr_count);\n\n    for (int i = 0; i \u003c arr_count; i++) {\n        string arr_item_temp;\n        getline(cin, arr_item_temp);\n\n        int arr_item = stoi(ltrim(rtrim(arr_item_temp)));\n\n        arr[i] = arr_item;\n    }\n\n    int result = segment(x, arr);\n\n    fout \u003c\u003c result \u003c\u003c \"\\n\";\n\n    fout.close();\n\n    return 0;\n}\n\nstring ltrim(const string \u0026str) {\n    string s(str);\n\n    s.erase(\n        s.begin(),\n        find_if(s.begin(), s.end(), not1(ptr_fun\u003cint, int\u003e(isspace)))\n    );\n\n    return s;\n}\n\nstring rtrim(const string \u0026str) {\n    string s(str);\n\n    s.erase(\n        find_if(s.rbegin(), s.rend(), not1(ptr_fun\u003cint, int\u003e(isspace))).base(),\n        s.end()\n    );\n\n    return s;\n}\n","csharp_template":"class Result\n{\n\n    /*\n     * Complete the 'segment' function below.\n     *\n     * The function is expected to return an INTEGER.\n     * The function accepts following parameters:\n     *  1. INTEGER x\n     *  2. INTEGER_ARRAY arr\n     */\n\n    public static int segment(int x, List\u003cint\u003e arr)\n    {\n\n    }\n\n}\n\n","csharp_template_head":"using System.CodeDom.Compiler;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.ComponentModel;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection;\nusing System.Runtime.Serialization;\nusing System.Text.RegularExpressions;\nusing System.Text;\nusing System;\n\n","csharp_template_tail":"class Solution\n{\n    public static void Main(string[] args)\n    {\n        TextWriter textWriter = new StreamWriter(@System.Environment.GetEnvironmentVariable(\"OUTPUT_PATH\"), true);\n\n        int x = Convert.ToInt32(Console.ReadLine().Trim());\n\n        int arrCount = Convert.ToInt32(Console.ReadLine().Trim());\n\n        List\u003cint\u003e arr = new List\u003cint\u003e();\n\n        for (int i = 0; i \u003c arrCount; i++)\n        {\n            int arrItem = Convert.ToInt32(Console.ReadLine().Trim());\n            arr.Add(arrItem);\n        }\n\n        int result = Result.segment(x, arr);\n\n        textWriter.WriteLine(result);\n\n        textWriter.Flush();\n        textWriter.Close();\n    }\n}\n","erlang_template":"%\n% Complete the 'segment' function below.\n%\n% The function is expected to return an INTEGER.\n% The function accepts following parameters:\n%  1. INTEGER x\n%  2. INTEGER_ARRAY arr\n%\n\nsegment(X, Arr) -\u003e\n    % Write your code here\n\n","erlang_template_head":"-module(solution).\n-export([main/0]).\n-import(os, [getenv/1]).\n\n","erlang_template_tail":"read_multiple_lines_as_list_of_strings(N) -\u003e\n    read_multiple_lines_as_list_of_strings(N, []).\n\nread_multiple_lines_as_list_of_strings(0, Acc) -\u003e\n    lists:reverse(Acc);\nread_multiple_lines_as_list_of_strings(N, Acc) when N \u003e 0 -\u003e\n    read_multiple_lines_as_list_of_strings(N - 1, [re:replace(io:get_line(\"\"), \"(\\\\r\\\\n$)|(\\\\n$)\", \"\", [global, {return, list}]) | Acc]).\n\nmain() -\u003e\n    {ok, Fptr} = file:open(getenv(\"OUTPUT_PATH\"), [write]),\n\n    {X, _} = string:to_integer(re:replace(io:get_line(\"\"), \"(^\\\\s+)|(\\\\s+$)\", \"\", [global, {return, list}])),\n\n    {ArrCount, _} = string:to_integer(re:replace(io:get_line(\"\"), \"(^\\\\s+)|(\\\\s+$)\", \"\", [global, {return, list}])),\n\n    ArrTemp = read_multiple_lines_as_list_of_strings(ArrCount),\n\n    Arr = lists:map(fun(X) -\u003e {I, _} = string:to_integer(re:replace(X, \"(^\\\\s+)|(\\\\s+$)\", \"\", [global, {return, list}])), I end, ArrTemp),\n\n    Result = segment(X, Arr),\n\n    io:fwrite(Fptr, \"~w~n\", [Result]),\n\n    file:close(Fptr),\n\n    ok.\n","go_template":"/*\n * Complete the 'segment' function below.\n *\n * The function is expected to return an INTEGER.\n * The function accepts following parameters:\n *  1. INTEGER x\n *  2. INTEGER_ARRAY arr\n */\n\nfunc segment(x int32, arr []int32) int32 {\n    // Write your code here\n\n}\n\n","go_template_head":"package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"io\"\n    \"os\"\n    \"strconv\"\n    \"strings\"\n)\n\n","go_template_tail":"func main() {\n    reader := bufio.NewReaderSize(os.Stdin, 16 * 1024 * 1024)\n\n    stdout, err := os.Create(os.Getenv(\"OUTPUT_PATH\"))\n    checkError(err)\n\n    defer stdout.Close()\n\n    writer := bufio.NewWriterSize(stdout, 16 * 1024 * 1024)\n\n    xTemp, err := strconv.ParseInt(strings.TrimSpace(readLine(reader)), 10, 64)\n    checkError(err)\n    x := int32(xTemp)\n\n    arrCount, err := strconv.ParseInt(strings.TrimSpace(readLine(reader)), 10, 64)\n    checkError(err)\n\n    var arr []int32\n\n    for i := 0; i \u003c int(arrCount); i++ {\n        arrItemTemp, err := strconv.ParseInt(strings.TrimSpace(readLine(reader)), 10, 64)\n        checkError(err)\n        arrItem := int32(arrItemTemp)\n        arr = append(arr, arrItem)\n    }\n\n    result := segment(x, arr)\n\n    fmt.Fprintf(writer, \"%d\\n\", result)\n\n    writer.Flush()\n}\n\nfunc readLine(reader *bufio.Reader) string {\n    str, _, err := reader.ReadLine()\n    if err == io.EOF {\n        return \"\"\n    }\n\n    return strings.TrimRight(string(str), \"\\r\\n\")\n}\n\nfunc checkError(err error) {\n    if err != nil {\n        panic(err)\n    }\n}\n","haskell_template":"--\n-- Complete the 'segment' function below.\n--\n-- The function is expected to return an INTEGER.\n-- The function accepts following parameters:\n--  1. INTEGER x\n--  2. INTEGER_ARRAY arr\n--\n\nsegment x arr = do\n    -- Write your code here\n\n","haskell_template_head":"{-# LANGUAGE DuplicateRecordFields, FlexibleInstances, UndecidableInstances #-}\n\nmodule Main where\n\nimport Control.Monad\nimport Data.Array\nimport Data.Bits\nimport Data.List\nimport Data.List.Split\nimport Data.Set\nimport Data.Text\nimport Debug.Trace\nimport System.Environment\nimport System.IO\nimport System.IO.Unsafe\n\n","haskell_template_tail":"lstrip = Data.Text.unpack . Data.Text.stripStart . Data.Text.pack\nrstrip = Data.Text.unpack . Data.Text.stripEnd . Data.Text.pack\n\nreadMultipleLinesAsStringArray :: Int -\u003e IO [String]\nreadMultipleLinesAsStringArray 0 = return []\nreadMultipleLinesAsStringArray n = do\n    line \u003c- getLine\n    rest \u003c- readMultipleLinesAsStringArray(n - 1)\n    return (line : rest)\n\nmain :: IO()\nmain = do\n    stdout \u003c- getEnv \"OUTPUT_PATH\"\n    fptr \u003c- openFile stdout WriteMode\n\n    xTemp \u003c- getLine\n    let x = read $ lstrip $ rstrip xTemp :: Int\n\n    arrCountTemp \u003c- getLine\n    let arrCount = read $ lstrip $ rstrip arrCountTemp :: Int\n\n    arrTemp \u003c- readMultipleLinesAsStringArray arrCount\n    let arr = Data.List.map (read :: String -\u003e Int) arrTemp\n\n    let result = segment x arr\n\n    hPutStrLn fptr $ show result\n\n    hFlush fptr\n    hClose fptr\n","java_template":"class Result {\n\n    /*\n     * Complete the 'segment' function below.\n     *\n     * The function is expected to return an INTEGER.\n     * The function accepts following parameters:\n     *  1. INTEGER x\n     *  2. INTEGER_ARRAY arr\n     */\n\n    public static int segment(int x, List\u003cInteger\u003e arr) {\n    // Write your code here\n\n    }\n\n}\n\n","java_template_head":"import java.io.*;\nimport java.math.*;\nimport java.security.*;\nimport java.text.*;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.regex.*;\n\n","java_template_tail":"public class Solution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(\"OUTPUT_PATH\")));\n\n        int x = Integer.parseInt(bufferedReader.readLine().trim());\n\n        int arrCount = Integer.parseInt(bufferedReader.readLine().trim());\n\n        List\u003cInteger\u003e arr = new ArrayList\u003c\u003e();\n\n        for (int i = 0; i \u003c arrCount; i++) {\n            int arrItem = Integer.parseInt(bufferedReader.readLine().trim());\n            arr.add(arrItem);\n        }\n\n        int result = Result.segment(x, arr);\n\n        bufferedWriter.write(String.valueOf(result));\n        bufferedWriter.newLine();\n\n        bufferedReader.close();\n        bufferedWriter.close();\n    }\n}\n","java8_template":"class Result {\n\n    /*\n     * Complete the 'segment' function below.\n     *\n     * The function is expected to return an INTEGER.\n     * The function accepts following parameters:\n     *  1. INTEGER x\n     *  2. INTEGER_ARRAY arr\n     */\n\n    public static int segment(int x, List\u003cInteger\u003e arr) {\n    // Write your code here\n\n    }\n\n}\n\n","java8_template_head":"import java.io.*;\nimport java.math.*;\nimport java.security.*;\nimport java.text.*;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.function.*;\nimport java.util.regex.*;\nimport java.util.stream.*;\nimport static java.util.stream.Collectors.joining;\nimport static java.util.stream.Collectors.toList;\n\n","java8_template_tail":"public class Solution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(\"OUTPUT_PATH\")));\n\n        int x = Integer.parseInt(bufferedReader.readLine().trim());\n\n        int arrCount = Integer.parseInt(bufferedReader.readLine().trim());\n\n        List\u003cInteger\u003e arr = IntStream.range(0, arrCount).mapToObj(i -\u003e {\n            try {\n                return bufferedReader.readLine().replaceAll(\"\\\\s+$\", \"\");\n            } catch (IOException ex) {\n                throw new RuntimeException(ex);\n            }\n        })\n            .map(String::trim)\n            .map(Integer::parseInt)\n            .collect(toList());\n\n        int result = Result.segment(x, arr);\n\n        bufferedWriter.write(String.valueOf(result));\n        bufferedWriter.newLine();\n\n        bufferedReader.close();\n        bufferedWriter.close();\n    }\n}\n","javascript_template":"/*\n * Complete the 'segment' function below.\n *\n * The function is expected to return an INTEGER.\n * The function accepts following parameters:\n *  1. INTEGER x\n *  2. INTEGER_ARRAY arr\n */\n\nfunction segment(x, arr) {\n    // Write your code here\n\n}\n\n","javascript_template_head":"'use strict';\n\nconst fs = require('fs');\n\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf-8');\n\nlet inputString = '';\nlet currentLine = 0;\n\nprocess.stdin.on('data', function(inputStdin) {\n    inputString += inputStdin;\n});\n\nprocess.stdin.on('end', function() {\n    inputString = inputString.split('\\n');\n\n    main();\n});\n\nfunction readLine() {\n    return inputString[currentLine++];\n}\n\n","javascript_template_tail":"function main() {\n    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);\n\n    const x = parseInt(readLine().trim(), 10);\n\n    const arrCount = parseInt(readLine().trim(), 10);\n\n    let arr = [];\n\n    for (let i = 0; i \u003c arrCount; i++) {\n        const arrItem = parseInt(readLine().trim(), 10);\n        arr.push(arrItem);\n    }\n\n    const result = segment(x, arr);\n\n    ws.write(result + '\\n');\n\n    ws.end();\n}\n","julia_template":"#\n# Complete the 'segment' function below.\n#\n# The function is expected to return an INTEGER.\n# The function accepts following parameters:\n#  1. INTEGER x\n#  2. INTEGER_ARRAY arr\n#\n\nfunction segment(x, arr)\n\nend\n\n","julia_template_head":"\n\n","julia_template_tail":"fptr = open(ENV[\"OUTPUT_PATH\"], \"w\")\n\nx = parse(Int32, strip(readline(stdin)))\n\narr_count = parse(Int32, strip(readline(stdin)))\n\narr = Array{Int32, 1}()\n\nfor _ = 1:arr_count\n    arr_item = parse(Int32, strip(readline(stdin)))\n    push!(arr, arr_item)\nend\n\nresult = segment(x, arr)\n\nwrite(fptr, string(result) * \"\\n\")\n\nclose(fptr)\n","kotlin_template":"/*\n * Complete the 'segment' function below.\n *\n * The function is expected to return an INTEGER.\n * The function accepts following parameters:\n *  1. INTEGER x\n *  2. INTEGER_ARRAY arr\n */\n\nfun segment(x: Int, arr: Array\u003cInt\u003e): Int {\n    // Write your code here\n\n}\n\n","kotlin_template_head":"import java.io.*\nimport java.math.*\nimport java.security.*\nimport java.text.*\nimport java.util.*\nimport java.util.concurrent.*\nimport java.util.function.*\nimport java.util.regex.*\nimport java.util.stream.*\nimport kotlin.collections.*\nimport kotlin.comparisons.*\nimport kotlin.io.*\nimport kotlin.jvm.*\nimport kotlin.jvm.functions.*\nimport kotlin.jvm.internal.*\nimport kotlin.ranges.*\nimport kotlin.sequences.*\nimport kotlin.text.*\n\n","kotlin_template_tail":"fun main(args: Array\u003cString\u003e) {\n    val x = readLine()!!.trim().toInt()\n\n    val arrCount = readLine()!!.trim().toInt()\n\n    val arr = Array\u003cInt\u003e(arrCount, { 0 })\n    for (i in 0 until arrCount) {\n        val arrItem = readLine()!!.trim().toInt()\n        arr[i] = arrItem\n    }\n\n    val result = segment(x, arr)\n\n    println(result)\n}\n","lua_template":"--\n-- Complete the 'segment' function below.\n--\n-- The function is expected to return an INTEGER.\n-- The function accepts following parameters:\n--  1. INTEGER x\n--  2. INTEGER_ARRAY arr\n--\n\nfunction segment(x, arr)\n    -- Write your code here\n\nend\n\n","lua_template_head":"\n\n","lua_template_tail":"local fptr = io.open(os.getenv(\"OUTPUT_PATH\"), \"w\")\n\nlocal x = io.stdin:read(\"*n\", \"*l\")\n\nlocal arrcount = io.stdin:read(\"*n\", \"*l\")\n\nlocal arr = {}\n\nfor i = 1, arrcount do\n    arr[i] = io.stdin:read(\"*n\", \"*l\")\nend\n\nlocal result = segment(x, arr)\n\nfptr:write(result, \"\\n\")\n\nfptr:close()\n","objectivec_template":"@interface Solution:NSObject\n- (NSNumber *) segment:(NSNumber *)x arr:(NSArray *)arr;\n@end\n\n@implementation Solution\n/*\n * Complete the 'segment' function below.\n *\n * The function is expected to return an INTEGER.\n * The function accepts following parameters:\n *  1. INTEGER x\n *  2. INTEGER_ARRAY arr\n */\n\n- (NSNumber *) segment:(NSNumber *)x arr:(NSArray *)arr {\n    // Write your code here\n\n}\n\n@end\n\n","objectivec_template_head":"#import \u003cFoundation/Foundation.h\u003e\n#import \u003cobjc/Object.h\u003e\n#import \u003cobjc/objc.h\u003e\n\n@interface NSString (NumberFromString)\n- (NSNumber *) numberFromString:(NSNumberFormatter *)formatter;\n@end\n\n@implementation NSString (NumberFromString)\n- (NSNumber *) numberFromString:(NSNumberFormatter *)formatter {\n    NSNumber *number = [formatter numberFromString:[self stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]]];\n\n    if (number == nil) {\n        [NSException raise:@\"Bad Input\" format:@\"%@\", self];\n    }\n\n    return number;\n}\n@end\n\n","objectivec_template_tail":"int main(int argc, const char* argv[]) {\n    @autoreleasepool {\n        NSString *stdout = [[[NSProcessInfo processInfo] environment] objectForKey:@\"OUTPUT_PATH\"];\n        [[NSFileManager defaultManager] createFileAtPath:stdout contents:nil attributes:nil];\n        NSFileHandle *fileHandle = [NSFileHandle fileHandleForWritingAtPath:stdout];\n\n        NSNumberFormatter *numberFormatter = [[NSNumberFormatter alloc] init];\n\n        NSData *availableInputData = [[NSFileHandle fileHandleWithStandardInput] availableData];\n        NSString *availableInputString = [[NSString alloc] initWithData:availableInputData encoding:NSUTF8StringEncoding];\n        NSArray *availableInputArray = [availableInputString componentsSeparatedByString:@\"\\n\"];\n\n        NSUInteger currentInputLine = 0;\n\n        NSNumber *x = [[[availableInputArray objectAtIndex:currentInputLine] stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]] numberFromString:numberFormatter];\n        currentInputLine += 1;\n\n        NSUInteger arrCount = [[[[availableInputArray objectAtIndex:currentInputLine] stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]] numberFromString:numberFormatter] integerValue];\n        currentInputLine += 1;\n\n        NSArray *arrTemp = [availableInputArray subarrayWithRange:NSMakeRange(currentInputLine, arrCount)];\n        currentInputLine += arrCount;\n\n        NSMutableArray *arrTempMutable = [NSMutableArray arrayWithCapacity:arrCount];\n\n        for (NSString *arrItem in arrTemp) {\n            [arrTempMutable addObject:[arrItem numberFromString:numberFormatter]];\n        }\n\n        NSArray *arr = [arrTempMutable copy];\n\n        NSNumber *result = [[[Solution alloc] init] segment:x arr:arr];\n\n        [fileHandle writeData:[[result stringValue] dataUsingEncoding:NSUTF8StringEncoding]];\n        [fileHandle writeData:[@\"\\n\" dataUsingEncoding:NSUTF8StringEncoding]];\n\n        [fileHandle closeFile];\n    }\n\n    return 0;\n}\n","perl_template":"#\n# Complete the 'segment' function below.\n#\n# The function is expected to return an INTEGER.\n# The function accepts following parameters:\n#  1. INTEGER x\n#  2. INTEGER_ARRAY arr\n#\n\nsub segment {\n    # Write your code here\n\n}\n\n","perl_template_head":"#!/usr/bin/perl\n\nuse strict;\nuse warnings;\n\n","perl_template_tail":"open(my $fptr, '\u003e', $ENV{'OUTPUT_PATH'});\n\nmy $x = ltrim(rtrim(my $x_temp = \u003cSTDIN\u003e));\n\nmy $arr_count = ltrim(rtrim(my $arr_count_temp = \u003cSTDIN\u003e));\n\nmy @arr = ();\n\nfor (1..$arr_count) {\n    my $arr_item = ltrim(rtrim(my $arr_item_temp = \u003cSTDIN\u003e));\n    push @arr, $arr_item;\n}\n\nmy $result = segment $x, \\@arr;\n\nprint $fptr \"$result\\n\";\n\nclose $fptr;\n\nsub ltrim {\n    my $str = shift;\n\n    $str =~ s/^\\s+//;\n\n    return $str;\n}\n\nsub rtrim {\n    my $str = shift;\n\n    $str =~ s/\\s+$//;\n\n    return $str;\n}\n","php_template":"/*\n * Complete the 'segment' function below.\n *\n * The function is expected to return an INTEGER.\n * The function accepts following parameters:\n *  1. INTEGER x\n *  2. INTEGER_ARRAY arr\n */\n\nfunction segment($x, $arr) {\n    // Write your code here\n\n}\n\n","php_template_head":"\u003c?php\n\n","php_template_tail":"$fptr = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n\n$x = intval(trim(fgets(STDIN)));\n\n$arr_count = intval(trim(fgets(STDIN)));\n\n$arr = array();\n\nfor ($i = 0; $i \u003c $arr_count; $i++) {\n    $arr_item = intval(trim(fgets(STDIN)));\n    $arr[] = $arr_item;\n}\n\n$result = segment($x, $arr);\n\nfwrite($fptr, $result . \"\\n\");\n\nfclose($fptr);\n","pypy_template":"#\n# Complete the 'segment' function below.\n#\n# The function is expected to return an INTEGER.\n# The function accepts following parameters:\n#  1. INTEGER x\n#  2. INTEGER_ARRAY arr\n#\n\ndef segment(x, arr):\n    # Write your code here\n\n","pypy_template_head":"#!/bin/python\n\nimport math\nimport os\nimport random\nimport re\nimport sys\n\n","pypy_template_tail":"if __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    x = int(raw_input().strip())\n\n    arr_count = int(raw_input().strip())\n\n    arr = []\n\n    for _ in xrange(arr_count):\n        arr_item = int(raw_input().strip())\n        arr.append(arr_item)\n\n    result = segment(x, arr)\n\n    fptr.write(str(result) + '\\n')\n\n    fptr.close()\n","pypy3_template":"#\n# Complete the 'segment' function below.\n#\n# The function is expected to return an INTEGER.\n# The function accepts following parameters:\n#  1. INTEGER x\n#  2. INTEGER_ARRAY arr\n#\n\ndef segment(x, arr):\n    # Write your code here\n\n","pypy3_template_head":"#!/bin/python3\n\nimport math\nimport os\nimport random\nimport re\nimport sys\n\n","pypy3_template_tail":"if __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    x = int(input().strip())\n\n    arr_count = int(input().strip())\n\n    arr = []\n\n    for _ in range(arr_count):\n        arr_item = int(input().strip())\n        arr.append(arr_item)\n\n    result = segment(x, arr)\n\n    fptr.write(str(result) + '\\n')\n\n    fptr.close()\n","python_template":"#\n# Complete the 'segment' function below.\n#\n# The function is expected to return an INTEGER.\n# The function accepts following parameters:\n#  1. INTEGER x\n#  2. INTEGER_ARRAY arr\n#\n\ndef segment(x, arr):\n    # Write your code here\n\n","python_template_head":"#!/bin/python\n\nimport math\nimport os\nimport random\nimport re\nimport sys\n\n","python_template_tail":"if __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    x = int(raw_input().strip())\n\n    arr_count = int(raw_input().strip())\n\n    arr = []\n\n    for _ in xrange(arr_count):\n        arr_item = int(raw_input().strip())\n        arr.append(arr_item)\n\n    result = segment(x, arr)\n\n    fptr.write(str(result) + '\\n')\n\n    fptr.close()\n","python3_template":"#\n# Complete the 'segment' function below.\n#\n# The function is expected to return an INTEGER.\n# The function accepts following parameters:\n#  1. INTEGER x\n#  2. INTEGER_ARRAY arr\n#\n\ndef segment(x, arr):\n    # Write your code here\n\n","python3_template_head":"#!/bin/python3\n\nimport math\nimport os\nimport random\nimport re\nimport sys\n\n","python3_template_tail":"if __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    x = int(input().strip())\n\n    arr_count = int(input().strip())\n\n    arr = []\n\n    for _ in range(arr_count):\n        arr_item = int(input().strip())\n        arr.append(arr_item)\n\n    result = segment(x, arr)\n\n    fptr.write(str(result) + '\\n')\n\n    fptr.close()\n","r_template":"#\n# Complete the 'segment' function below.\n#\n# The function is expected to return an INTEGER.\n# The function accepts following parameters:\n#  1. INTEGER x\n#  2. INTEGER_ARRAY arr\n#\n\nsegment \u003c- function(x, arr) {\n    # Write your code here\n\n}\n\n","r_template_head":"\n\n","r_template_tail":"stdin \u003c- file('stdin')\nopen(stdin)\n\nfptr \u003c- file(Sys.getenv(\"OUTPUT_PATH\"))\nopen(fptr, open = \"w\")\n\nx \u003c- as.integer(trimws(readLines(stdin, n = 1, warn = FALSE), which = \"both\"))\n\narrCount \u003c- as.integer(trimws(readLines(stdin, n = 1, warn = FALSE), which = \"both\"))\narr \u003c- readLines(stdin, n = arrCount, warn = FALSE)\narr \u003c- trimws(arr, which = \"both\")\narr \u003c- as.integer(arr)\n\nresult \u003c- segment(x, arr)\n\nwriteLines(as.character(result), con = fptr)\n\nclose(stdin)\nclose(fptr)\n","ruby_template":"#\n# Complete the 'segment' function below.\n#\n# The function is expected to return an INTEGER.\n# The function accepts following parameters:\n#  1. INTEGER x\n#  2. INTEGER_ARRAY arr\n#\n\ndef segment(x, arr)\n    # Write your code here\n\nend\n\n","ruby_template_head":"#!/bin/ruby\n\nrequire 'json'\nrequire 'stringio'\n\n","ruby_template_tail":"fptr = File.open(ENV['OUTPUT_PATH'], 'w')\n\nx = gets.strip.to_i\n\narr_count = gets.strip.to_i\n\narr = Array.new(arr_count)\n\narr_count.times do |i|\n    arr_item = gets.strip.to_i\n    arr[i] = arr_item\nend\n\nresult = segment x, arr\n\nfptr.write result\nfptr.write \"\\n\"\n\nfptr.close()\n","scala_template":"object Result {\n\n    /*\n     * Complete the 'segment' function below.\n     *\n     * The function is expected to return an INTEGER.\n     * The function accepts following parameters:\n     *  1. INTEGER x\n     *  2. INTEGER_ARRAY arr\n     */\n\n    def segment(x: Int, arr: Array[Int]): Int = {\n\n    }\n\n}\n\n","scala_template_head":"import java.io._\nimport java.math._\nimport java.security._\nimport java.text._\nimport java.util._\nimport java.util.concurrent._\nimport java.util.function._\nimport java.util.regex._\nimport java.util.stream._\nimport scala.collection.immutable._\nimport scala.collection.mutable._\nimport scala.collection.concurrent._\nimport scala.concurrent._\nimport scala.io._\nimport scala.math._\nimport scala.sys._\nimport scala.util.matching._\nimport scala.reflect._\n\n","scala_template_tail":"object Solution {\n    def main(args: Array[String]) {\n        val printWriter = new PrintWriter(sys.env(\"OUTPUT_PATH\"))\n\n        val x = StdIn.readLine.trim.toInt\n\n        val arrCount = StdIn.readLine.trim.toInt\n\n        val arr = Array.ofDim[Int](arrCount)\n\n        for (i \u003c- 0 until arrCount) {\n            val arrItem = StdIn.readLine.trim.toInt\n            arr(i) = arrItem\n        }\n\n        val result = Result.segment(x, arr)\n\n        printWriter.println(result)\n\n        printWriter.close()\n    }\n}\n","swift_template":"/*\n * Complete the 'segment' function below.\n *\n * The function is expected to return an INTEGER.\n * The function accepts following parameters:\n *  1. INTEGER x\n *  2. INTEGER_ARRAY arr\n */\n\nfunc segment(x: Int, arr: [Int]) -\u003e Int {\n\n}\n\n","swift_template_head":"import Foundation\n\n","swift_template_tail":"let stdout = ProcessInfo.processInfo.environment[\"OUTPUT_PATH\"]!\nFileManager.default.createFile(atPath: stdout, contents: nil, attributes: nil)\nlet fileHandle = FileHandle(forWritingAtPath: stdout)!\n\nguard let x = Int((readLine()?.trimmingCharacters(in: .whitespacesAndNewlines))!)\nelse { fatalError(\"Bad input\") }\n\nguard let arrCount = Int((readLine()?.trimmingCharacters(in: .whitespacesAndNewlines))!)\nelse { fatalError(\"Bad input\") }\n\nvar arr = [Int]()\n\nfor _ in 1...arrCount {\n    guard let arrItem = Int((readLine()?.trimmingCharacters(in: .whitespacesAndNewlines))!)\n    else { fatalError(\"Bad input\") }\n\n    arr.append(arrItem)\n}\n\nguard arr.count == arrCount else { fatalError(\"Bad input\") }\n\nlet result = segment(x: x, arr: arr)\n\nfileHandle.write(String(result).data(using: .utf8)!)\nfileHandle.write(\"\\n\".data(using: .utf8)!)\n","solve":{"answer":{"code":"\nclass Result {\n\n    /*\n     * Complete the 'segment' function below.\n     *\n     * The function is expected to return an INTEGER.\n     * The function accepts following parameters:\n     *  1. INTEGER x\n     *  2. INTEGER_ARRAY arr\n     */\n\n    public static int segment(int x, List\u003cInteger\u003e arr) {\n    // Write your code here\n        int tree[] = new int[2097153];\n        int N = arr.size();\n        \n        int leaf_node_start = 1;\n        for(; leaf_node_start \u003c N; leaf_node_start=leaf_node_start*2);\n        \n        for(int i=0; i\u003cN; i++) {\n            tree[i + leaf_node_start] = arr.get(i);\n        }\n        \n        for(int i=leaf_node_start-1; i\u003e=1; i--) {\n            tree[i] = Math.min(tree[i*2], tree[i*2+1]);\n        }\n        \n        int MIN, MAX=0, l, r;\n        for(int i=0; i\u003c=N-x; i++) {\n            MIN = Integer.MAX_VALUE;\n            \n            l = i + leaf_node_start; \n            r = l + x - 1;\n            \n            while( l \u003c= r ) {\n                if(l%2 == 1) MIN = Math.min(tree[l], MIN);\n                if(r%2 == 0) MIN = Math.min(tree[r], MIN);\n                \n                l = (l+1)/2;\n                r = (r-1)/2;\n            }\n            \n            MAX = Math.max(MIN, MAX);\n        }\n\n        return MAX;\n    }\n\n}\n","language":"java8"}},"nextqid":null,"prevqid":"2blct447d26","qno":3,"has_samples":true,"file_tree":null,"total_test_cases_count":15,"sample_test_cases_count":3,"projects_instructions":null,"firepad_url":"https://hrcandidate.firebaseio.com/4ef518509647fd15bd5b384ef30b785c8ec849d9","token":"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ2IjowLCJpYXQiOjE1ODU1Nzc3NjIsImQiOnsidWlkIjoiNGVmNTE4NTA5NjQ3ZmQxNWJkNWIzODRlZjMwYjc4NWM4ZWM4NDlkOSIsInNsdWciOiI0ZWY1MTg1MDk2NDdmZDE1YmQ1YjM4NGVmMzBiNzg1YzhlYzg0OWQ5In19.7FpUyfxZEbU0b9_K0ho6UfJnBoRQwLngyO7FrqYiGM8","first_sample_input":"1\n5\n1\n2\n3\n1\n2"}}